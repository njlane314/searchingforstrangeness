#ifndef ANALYSIS_EVENTCATEGORY
#define ANALYSIS_EVENTCATEGORY

#include <iostream>
#include "AnalysisToolBase.h"
#include "TDatabasePDG.h"
#include "TParticlePDG.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "lardataobj/MCBase/MCShower.h"
#include "TVector3.h"
#include "CommonFunctions/Backtracking.h"
#include "CommonFunctions/Scores.h"
#include "CommonFunctions/Corrections.h"
#include "CommonFunctions/Scatters.h"
#include "CommonFunctions/Geometry.h"
#include "CommonFunctions/Pandora.h"
#include "larpandora/LArPandoraInterface/LArPandoraHelper.h"

namespace analysis
{
struct Particle {
    int tid = -1;
    int pdg = 0;
    float energy = std::numeric_limits<float>::lowest();
    float px = std::numeric_limits<float>::lowest(), py = std::numeric_limits<float>::lowest(), pz = std::numeric_limits<float>::lowest();
    float startx = std::numeric_limits<float>::lowest(), starty = std::numeric_limits<float>::lowest(), startz = std::numeric_limits<float>::lowest();
    float endx = std::numeric_limits<float>::lowest(), endy = std::numeric_limits<float>::lowest(), endz = std::numeric_limits<float>::lowest();
    unsigned int n_elas = 0; 
    unsigned int n_inelas = 0;
    std::string endstate = "";
};

struct Neutrino {
    int nu_pdg = -1;         
    int ccnc = -1;    
    int mode = -1;        
    int interaction = -1; 
    float nu_e = std::numeric_limits<float>::lowest();   
    float nu_theta = std::numeric_limits<float>::lowest();   
    float nu_pt = std::numeric_limits<float>::lowest();     
    int target_nucleus = -1;
    int hit_nucleon = -1;
    float W = std::numeric_limits<float>::lowest();
    float X = std::numeric_limits<float>::lowest();
    float Y = std::numeric_limits<float>::lowest();
    float QSqr = std::numeric_limits<float>::lowest();
    float px = std::numeric_limits<float>::lowest(), py = std::numeric_limits<float>::lowest(), pz = std::numeric_limits<float>::lowest();
    float true_vtx_sce_x = std::numeric_limits<float>::lowest(), true_vtx_sce_y = std::numeric_limits<float>::lowest(), true_vtx_sce_z = std::numeric_limits<float>::lowest();
    float true_vtx_sce_u_wire = std::numeric_limits<float>::lowest(), true_vtx_sce_w_wire = std::numeric_limits<float>::lowest(), true_vtx_sce_v_wire = std::numeric_limits<float>::lowest();
};

class EventCategoryAnalysis : public AnalysisToolBase
{
public:
    EventCategoryAnalysis(const fhicl::ParameterSet &pset);
    ~EventCategoryAnalysis(){};

    void configure(fhicl::ParameterSet const &pset);
    void analyseEvent(art::Event const &e, bool is_data) override;
    void setBranches(TTree *_tree) override;
    void resetTTree(TTree *_tree) override;

    void setParticleBranches(TTree *_tree, const std::string &prefix, Particle &particle)
    {
        _tree->Branch((prefix + "_tid").c_str(), &particle.tid, (prefix + "_tid/I").c_str());
        _tree->Branch((prefix + "_pdg").c_str(), &particle.pdg, (prefix + "_pdg/I").c_str());
        _tree->Branch((prefix + "_energy").c_str(), &particle.energy, (prefix + "_energy/F").c_str());
        _tree->Branch((prefix + "_px").c_str(), &particle.px, (prefix + "_px/F").c_str());
        _tree->Branch((prefix + "_py").c_str(), &particle.py, (prefix + "_py/F").c_str());
        _tree->Branch((prefix + "_pz").c_str(), &particle.pz, (prefix + "_pz/F").c_str());
        _tree->Branch((prefix + "_startx").c_str(), &particle.startx, (prefix + "_startx/F").c_str());
        _tree->Branch((prefix + "_starty").c_str(), &particle.starty, (prefix + "_starty/F").c_str());
        _tree->Branch((prefix + "_startz").c_str(), &particle.startz, (prefix + "_startz/F").c_str());
        _tree->Branch((prefix + "_endx").c_str(), &particle.endx, (prefix + "_endx/F").c_str());
        _tree->Branch((prefix + "_endy").c_str(), &particle.endy, (prefix + "_endy/F").c_str());
        _tree->Branch((prefix + "_endz").c_str(), &particle.endz, (prefix + "_endz/F").c_str());
        _tree->Branch((prefix + "_n_elas").c_str(), &particle.n_elas, (prefix + "_n_elas/I").c_str());
        _tree->Branch((prefix + "_n_inelas").c_str(), &particle.n_inelas, (prefix + "_n_inelas/I").c_str());
        _tree->Branch((prefix + "_endstate").c_str(), &particle.endstate);
    }

    void fillNeutrino(Neutrino& p, const simb::MCNeutrino& neutrino, const simb::MCParticle& nu)
    {
        p.nu_pdg = nu.PdgCode();
        p.nu_e = nu.Trajectory().E(0);
        p.nu_theta = neutrino.Theta();
        p.nu_pt = neutrino.Pt();
        p.ccnc = neutrino.CCNC();
        p.mode = neutrino.Mode();            
        p.interaction = neutrino.InteractionType(); 
        p.target_nucleus = neutrino.Target();
        p.hit_nucleon = neutrino.HitNuc();
        p.W = neutrino.W();
        p.X = neutrino.X();
        p.Y = neutrino.Y();
        p.QSqr = neutrino.QSqr();

        p.px = nu.Px();
        p.py = nu.Py();
        p.pz = nu.Pz();
    
        float true_nu_vtx_sce[3];
        common::True2RecoMappingXYZ(nu.T(), nu.Vx(), nu.Vy(), nu.Vz(), true_nu_vtx_sce);

        p.true_vtx_sce_x = true_nu_vtx_sce[0];
        p.true_vtx_sce_y = true_nu_vtx_sce[1];
        p.true_vtx_sce_z = true_nu_vtx_sce[2];

        p.true_vtx_sce_u_wire = (common::ProjectToWireView(p.true_vtx_sce_x, p.true_vtx_sce_y, p.true_vtx_sce_z, common::TPC_VIEW_U)).Z(); 
        p.true_vtx_sce_v_wire = (common::ProjectToWireView(p.true_vtx_sce_x, p.true_vtx_sce_y, p.true_vtx_sce_z, common::TPC_VIEW_V)).Z(); 
        p.true_vtx_sce_w_wire = (common::ProjectToWireView(p.true_vtx_sce_x, p.true_vtx_sce_y, p.true_vtx_sce_z, common::TPC_VIEW_W)).Z(); 
    }

    void fillParticle(const art::ValidHandle<std::vector<simb::MCParticle>>& mcp_h, const art::Ptr<simb::MCParticle>& particle, Particle& p)
    {
        p.tid = particle->TrackId();
        p.pdg = particle->PdgCode();
        p.energy = particle->E();
        p.px = particle->Px();
        p.py = particle->Py();
        p.pz = particle->Pz();
        p.startx = particle->Vx();
        p.starty = particle->Vy();
        p.startz = particle->Vz();
        p.endx = particle->EndX();
        p.endy = particle->EndY();
        p.endz = particle->EndZ();
    }

private:
    art::InputTag _MCTproducer, _MCPproducer, _Hproducer, _BacktrackTag, _PFPproducer, _CLSproducer, _SLCproducer, _TRKproducer, _VTXproducer, _PCAproducer, _SHRproducer;
    Neutrino _neutrino;
    std::vector<int> _final_state;
};

EventCategoryAnalysis::EventCategoryAnalysis(const fhicl::ParameterSet &pset)
{
    _MCTproducer = pset.get<art::InputTag>("MCTproducer", "generator");
    _MCPproducer = pset.get<art::InputTag>("MCPproducer", "largeant");
    _Hproducer = pset.get<art::InputTag>("Hproducer", "gaushit");
    _BacktrackTag = pset.get<art::InputTag>("BacktrackTag", "gaushitTruthMatch");
    _PFPproducer = pset.get<art::InputTag>("PFPproducer", "pandora");
    _CLSproducer = pset.get<art::InputTag>("CLSproducer", "pandora");
    _SLCproducer = pset.get<art::InputTag>("SLCproducer", "pandora");
    _TRKproducer = pset.get<art::InputTag>("TRKproducer", "pandora");
    _VTXproducer = pset.get<art::InputTag>("VTXproducer", "pandora");
    _PCAproducer = pset.get<art::InputTag>("PCAproducer", "pandora");
    _SHRproducer = pset.get<art::InputTag>("SHRproducer", "pandora"); 
}

void EventCategoryAnalysis::configure(fhicl::ParameterSet const &pset)
{
}

void EventCategoryAnalysis::analyseEvent(art::Event const &e, bool is_data)
{
    if (is_data)
        return;

    auto const &mct_h = e.getValidHandle<std::vector<simb::MCTruth>>(_MCTproducer);
    auto const &mcp_h = e.getValidHandle<std::vector<simb::MCParticle>>(_MCPproducer);
    std::map<int, art::Ptr<simb::MCParticle>> mcp_map; 
    for (size_t mcp_iter = 0; mcp_iter < mcp_h->size(); mcp_iter) {
        const art::Ptr<simb::MCParticle> mcp(mcp_h, mcp_iter);
        mcp_map[mcp->TrackId()] = mcp;
    }

    auto mct = mct_h->at(0);
    if (mct.NeutrinoSet()) {
        auto const &neutrino = mct.GetNeutrino();
        auto const &nu = neutrino.Nu();
        this->fillNeutrino(_neutrino, neutrino, nu);
    }
}

void EventCategoryAnalysis::setBranches(TTree *_tree)
{
    _tree->Branch("nu_pdg", &_neutrino.nu_pdg, "nu_pdg/I");
    _tree->Branch("ccnc", &_neutrino.ccnc, "ccnc/I");
    _tree->Branch("nu_e", &_neutrino.nu_e, "nu_e/F");
    _tree->Branch("nu_theta", &_neutrino.nu_theta, "nu_theta/F");
    _tree->Branch("nu_pt", &_neutrino.nu_pt, "nu_pt/F");
    _tree->Branch("target_nucleus", &_neutrino.target_nucleus, "target_nucleus/I");
    _tree->Branch("hit_nucleon", &_neutrino.hit_nucleon, "hit_nucleon/I");
    _tree->Branch("W", &_neutrino.W, "W/F");
    _tree->Branch("X", &_neutrino.X, "X/F");
    _tree->Branch("Y", &_neutrino.Y, "Y/F");
    _tree->Branch("QSqr", &_neutrino.QSqr, "QSqr/F");
    
    _tree->Branch("true_vtx_sce_x", &_neutrino.true_vtx_sce_x, "true_vtx_sce_x/F");
    _tree->Branch("true_vtx_sce_y", &_neutrino.true_vtx_sce_y, "true_vtx_sce_y/F");
    _tree->Branch("true_vtx_sce_z", &_neutrino.true_vtx_sce_z, "true_vtx_sce_z/F");
    _tree->Branch("true_vtx_sce_u_wire", &_neutrino.true_vtx_sce_u_wire, "true_vtx_sce_u_wire/F");
    _tree->Branch("true_vtx_sce_v_wire", &_neutrino.true_vtx_sce_v_wire, "true_vtx_sce_v_wire/F");
    _tree->Branch("true_vtx_sce_w_wire", &_neutrino.true_vtx_sce_w_wire, "true_vtx_sce_w_wire/F");
}

void EventCategoryAnalysis::resetTTree(TTree *_tree)
{
    _neutrino = Neutrino();
}

DEFINE_ART_CLASS_TOOL(EventCategoryAnalysis)
} 

#endif