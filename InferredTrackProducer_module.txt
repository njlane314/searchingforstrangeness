#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "fhiclcpp/ParameterSet.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Hit.h"

#include "larcontent/LArPfoHelper.h"  
#include "larcontent/LArTrackState.h"
#include "larcontent/LArTrackStateVector.h"

#include <vector>
#include <map>
#include <memory>

class InferredTrackProducer : public art::EDProducer 
{
public:
    explicit InferredTrackProducer(fhicl::ParameterSet const& pset);

    void produce(art::Event& evt) override;

private:
    int _track_counter;  
    std::unique_ptr<ConvolutionNetworkAlgo> _cnn_algo; 

    void buildTrack(const std::vector<art::Ptr<recob::Hit>>& hits, recob::Track& track);
};

InferredTrackProducer::InferredTrackProducer(fhicl::ParameterSet const& pset)
    : EDProducer{pset}
    , _track_counter(1000) 
    , _cnn_algo(std::make_unique<ConvolutionNetworkAlgo>(pset)) 
{
    produces<std::vector<recob::Track>>(); 
}

void InferredTrackProducer::produce(art::Event& evt) 
{
    std::map<int, std::vector<art::Ptr<recob::Hit>>> classified_hits;
    _cnn_algo->infer(evt, classified_hits); 

    auto track_coll = std::make_unique<std::vector<recob::Track>>();

    for (const auto& [class_id, hits] : classified_hits) 
    {
        if (hits.empty()) 
            continue;

        recob::Track track;
        this->buildTrack(hits, track);

        track_coll->emplace_back(std::move(track));
    }

    evt.put(std::move(track_coll));
}

recob::Track InferredTrackProducer::buildTrack(const std::vector<art::Ptr<recob::Hit>>& hits, recob::Track& track)
{
    // need to build new pfp particle 
    pandora::CartesianPointVector cartesian_point_vector;
    for (const art::Ptr<recob::SpacePoint> sp : sp_coll)
        cartesian_point_vector.emplace_back(pandora::CartesianVector(sp->XYZ()[0], sp->XYZ()[1], sp->XYZ()[2]));
}

DEFINE_ART_MODULE(InferredTrackProducer)
