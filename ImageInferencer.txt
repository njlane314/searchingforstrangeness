#ifndef IMAGEINFERENCER_H
#define IMAGEINFERENCER_H

#include "fhiclcpp/ParameterSet.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "lardataobj/RecoBase/Wire.h"
#include "Geometry/GeometryCore.h"
#include "ImageProcessor.h" 
#include <torch/torch.h>
#include <torch/script.h>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <iostream>
#include <map>
#include "cetlib_except/exception.h"
#include "cetlib/search_path.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"

namespace image {

class ImageInferencer {
public:
    explicit ImageInferencer(const fhicl::ParameterSet &pset, const geo::GeometryCore* geo)
        : _geo(geo)
    {
        _image_width    = pset.get<int>("ImageWidth", 256);
        _image_height   = pset.get<int>("ImageHeight", 256);

        auto detProp = art::ServiceHandle<detinfo::DetectorPropertiesService>()->provider();
        _drift_step = (detProp->SamplingRate() / 1000.) *
                      detProp->DriftVelocity(detProp->Efield(), detProp->Temperature());

        _wire_pitch_u = _geo->WirePitch(geo::kU);
        _wire_pitch_v = _geo->WirePitch(geo::kV);
        _wire_pitch_w = _geo->WirePitch(geo::kW);

        try {
            _model_u = std::make_shared<torch::jit::script::Module>(
                        torch::jit::load(pset.get<std::string>("ModelFileU")));
            _model_v = std::make_shared<torch::jit::script::Module>(
                        torch::jit::load(pset.get<std::string>("ModelFileV")));
            _model_w = std::make_shared<torch::jit::script::Module>(
                        torch::jit::load(pset.get<std::string>("ModelFileW")));
        } catch (const c10::Error & e) {
            throw cet::exception("ImageInferencer")
                << "Error loading torch models: " << e.what();
        }
    }

    ImageInferencer(const ImageInferencer&) = delete;
    ImageInferencer(ImageInferencer&&) = delete;
    ImageInferencer& operator=(const ImageInferencer&) = delete;
    ImageInferencer& operator=(ImageInferencer&&) = delete;

    std::vector<SignatureType> infer(const std::vector<art::Ptr<recob::Wire>>& wires,
                                     const std::vector<image::ImageMeta>& metas)
    {
        std::vector<image::Image> images = image::WiresToImages(metas, wires, *_geo);
        std::vector<SignatureType> inferred_signatures;

        for (const auto &img : images) {
            torch::Tensor tensor = img.tensor();
            geo::View_t view = img.getMeta().view();
            torch::Tensor output;

            if (view == geo::kU) {
                output = _model_u->forward({tensor}).toTensor();
            } else if (view == geo::kV) {
                output = _model_v->forward({tensor}).toTensor();
            } else if (view == geo::kW) {
                output = _model_w->forward({tensor}).toTensor();
            } else {
                continue;
            }

            auto max_idx = output.argmax(1).item<int>();
            inferred_signatures.push_back(static_cast<SignatureType>(max_idx));
        }

        return inferred_signatures;
    }

private:
    int _image_width;
    int _image_height;
    float _drift_step;
    float _wire_pitch_u;
    float _wire_pitch_v;
    float _wire_pitch_w;

    const geo::GeometryCore* _geo;
    const detinfo::DetectorProperties* _detp;

    std::shared_ptr<torch::jit::script::Module> _model_u;
    std::shared_ptr<torch::jit::script::Module> _model_v;
    std::shared_ptr<torch::jit::script::Module> _model_w;
};

}

#endif // IMAGEINFERENCER_H
