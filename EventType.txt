#ifndef EVENT_TYPE_H
#define EVENT_TYPE_H

#include "art/Framework/Principal/Event.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "larcore/Geometry/Geometry.h"
#include "TLorentzVector.h"
#include <vector>
#include <map>
#include <cmath>

namespace event {

enum EventType {
    Unknown = 0,
    Signal,
    CosmicBackground,
    BeamInducedBackground,
    NoiseBackground,
    ExternalBackground,  
    OtherBackground      
};

class EventTypeClassifier {
public:
    EventTypeClassifier(const geo::GeometryCore* geo, double momentumThreshold)
        : _geo(geo), _momentumThreshold(momentumThreshold) {}

    // Check if neutrino interaction vertex is within active detector volume
    bool isWithinActiveVolume(const TLorentzVector& vertex) const {
        double x = vertex.X();
        double y = vertex.Y();
        double z = vertex.Z();

        // Define the active volume boundaries (adjust as needed)
        double minX = 0.0, maxX = 256.35;
        double minY = -116.5, maxY = 116.5;
        double minZ = 0.0, maxZ = 1036.8;

        return (x >= minX && x <= maxX) &&
               (y >= minY && y <= maxY) &&
               (z >= minZ && z <= maxZ);
    }

    // Check if the particle has sufficient momentum
    bool hasSufficientMomentum(const art::Ptr<simb::MCParticle>& particle) const {
        return particle->P() >= _momentumThreshold;
    }

    // Determine the type of event: Signal or specific Background
    EventType classifyEvent(const art::Event& evt) const {
        auto const& mcp_h = evt.getValidHandle<std::vector<simb::MCParticle>>("largeant");

        bool inActiveVolume = false;
        bool sufficientMomentum = true;
        bool externalOrigin = false;
        bool otherBackgroundDetected = false;

        for (const auto& mcp : *mcp_h) {
            // Ensure primary neutrino interaction is within the active volume
            if ((abs(mcp.PdgCode()) == 12 || abs(mcp.PdgCode()) == 14) && mcp.Process() == "primary") {
                if (isWithinActiveVolume(mcp.Vx4())) {
                    inActiveVolume = true;
                } else {
                    externalOrigin = true;
                }
            }

            // Check for particles (e.g., kaon-short decay products) meeting momentum criteria
            if (abs(mcp.PdgCode()) == 211 && !hasSufficientMomentum(mcp)) {  // pion check
                sufficientMomentum = false;
            }

            // Identify other backgrounds based on process or origin
            if (mcp.Process() == "unknown" || mcp.PdgCode() == 0) {
                otherBackgroundDetected = true;
            }
        }

        if (inActiveVolume && sufficientMomentum) {
            return Signal;
        } else if (externalOrigin && sufficientMomentum) {
            return ExternalBackground;
        } else if (!inActiveVolume && sufficientMomentum) {
            return CosmicBackground;
        } else if (inActiveVolume && !sufficientMomentum) {
            return BeamInducedBackground;
        } else if (otherBackgroundDetected) {
            return OtherBackground;
        } else {
            return NoiseBackground;
        }
    }

private:
    const geo::GeometryCore* _geo;
    double _momentumThreshold;
};

} // namespace event

#endif // EVENT_TYPE_H
